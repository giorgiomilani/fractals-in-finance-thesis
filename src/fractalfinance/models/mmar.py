"""
Multifractal Model of Asset Returns (MMAR)
=========================================

X(t) = B_H(θ(t)), where

* θ(t) is a multifractal “trading‑time” clock built with a binomial
  multiplicative cascade (μ‑measure on 2^depth bins, integrated to θ).
* B_H is fractional Brownian motion with Hurst exponent H, generated by
  the exact O(N log N) Davies–Harte method.

This module provides a single entry‑point:

    theta, X, r = mmar_simulate(n, H=0.7)
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Tuple

import numpy as np
from numpy.typing import ArrayLike

# ────────────────────────────────────────────
#   1.  MULTIFRACTAL CASCADE
# ────────────────────────────────────────────


@dataclass
class CascadeParams:
    m_L: float = 0.6          # low multiplier
    m_H: float = 1.4          # high multiplier
    depth: int = 9            # 2^depth bins in the finest scale
    seed: int | None = None


def _multiplicative_cascade(p: CascadeParams) -> np.ndarray:
    """
    Build the binomial cascade measure μ_i on 2^depth bins.

    At each level each *parent* bin splits into two *children* and each
    child mass is multiplied by either m_L or m_H with equal
    probability (independent between bins).
    """
    rng = np.random.default_rng(p.seed)
    mu = np.ones(1, dtype=float)          # start with a single bin of mass 1

    for _ in range(p.depth):
        mu = np.repeat(mu, 2)                                      # split
        multipliers = rng.choice([p.m_L, p.m_H], size=mu.size)     # i.i.d.
        mu *= multipliers

    return mu / mu.sum()            # normalise to total mass 1


# ────────────────────────────────────────────
#   2.  DAVIES–HARTE FGN / FBM
# ────────────────────────────────────────────
def _fgn_davies_harte(n: int, H: float, rng: np.random.Generator) -> np.ndarray:
    """
    Exact fractional‑Gaussian‑noise (length n) using the
    Davies–Harte circulant‑embedding algorithm.

    Steps
    -----
    1.  Build the first row of the circulant covariance matrix.
    2.  FFT → eigenvalues λ_k ≥ 0.
    3.  Construct a Hermitian Gaussian vector of size 2n with
        variances λ_k/(2n), guaranteeing real output after IFFT.
    4.  IFFT and keep the first *n* real entries.

    Returns
    -------
    fgn : np.ndarray   length n, Var=1
    """
    k = np.arange(n)
    gamma = 0.5 * ((k + 1) ** (2 * H) - 2 * k ** (2 * H) + np.abs(k - 1) ** (2 * H))
    g = np.concatenate([gamma, [0.0], gamma[1:][::-1]])  # length 2n
    eigs = np.fft.fft(g).real
    if np.any(eigs < 0):
        raise ValueError("Covariance embedding not positive‑definite — "
                         "increase n to next power‑of‑two.")

    # complex Gaussian vector with Hermitian symmetry
    Z = np.empty(2 * n, dtype=np.complex128)
    Z[0] = rng.normal() * np.sqrt(eigs[0] / (2 * n))
    Z[n] = rng.normal() * np.sqrt(eigs[n] / (2 * n))     # Nyquist (real)
    W = rng.normal(size=n - 1) + 1j * rng.normal(size=n - 1)
    Z[1:n] = W * np.sqrt(eigs[1:n] / (4 * n))
    Z[n + 1 :] = np.conj(Z[1:n][::-1])

    fgn = np.fft.ifft(Z).real[:n]
    return fgn / fgn.std(ddof=0)        # unit variance


# ────────────────────────────────────────────
#   3.  PUBLIC SIMULATOR
# ────────────────────────────────────────────
def mmar_simulate(
    n: int,
    H: float = 0.7,
    *,
    cascade: CascadeParams | None = None,
    seed: int | None = None,
) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Simulate an MMAR path of length *n*.

    Parameters
    ----------
    n : int
        Number of observations.
    H : float
        Hurst exponent of the background FBM (0 < H < 1).
    cascade : CascadeParams, optional
        Parameters of the multiplicative cascade.  Defaults m_L=0.6,
        m_H=1.4, depth=9.
    seed : int, optional
        Random‑number seed for reproducibility.

    Returns
    -------
    theta : np.ndarray  multifractal clock, monotone in [0, 1]
    X     : np.ndarray  sample path of B_H(θ(t))
    r     : np.ndarray  returns ΔX (mean‑zero)
    """
    cascade = cascade or CascadeParams()
    rng = np.random.default_rng(seed)

    # --- trading‑time measure & clock θ(t) -----------------------------
    mu = _multiplicative_cascade(cascade)          # length 2^depth
    # give each μ_i an equal share of discrete time steps
    steps_per_bin = n // mu.size
    if steps_per_bin == 0:
        raise ValueError("n must be at least 2^depth")
    theta = np.repeat(mu, steps_per_bin).cumsum()
    theta = theta[:n] / theta.sum()                # θ ∈ [0,1]

    # --- FBM evaluated at θ -------------------------------------------
    fgn = _fgn_davies_harte(n, H, rng)             # ΔB_H, Var=1
    # integrate by linear interpolation from θ to equidistant grid
    X = np.cumsum(np.interp(np.linspace(0, 1, n), theta, fgn))

    # returns (centre to zero mean)
    r = np.diff(np.insert(X, 0, X[0]))
    r = r - r.mean()
    return theta, X, r

# ---------------------------------------------------------------------- #
# backward‑compatibility
simulate = mmar_simulate
